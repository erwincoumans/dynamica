/*
Bullet Continuous Collision Detection and Physics Library Maya Plugin
Copyright (c) 2008 Walt Disney Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising
from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must
not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Nicola Candussi <nicola@fluidinteractive.com>

Modified by Roman Ponomarev <rponom@gmail.com>
01/22/2010 : Constraints reworked

Modified by Michael Baker <michael@mBakr.com>
*/
//init
global proc dynamicaUI_initialize() //this proc is called from the plugin
{	
	print("Loading Dynamica plugin...\n");
	
	global float $dynamicaUI_startFrame;
	global float $dynamicaUI_bakeStartFrame;
	global float $dynamicaUI_bakeEndFrame;
	
	source "mbUtils";

	//add Dynamica menu to the main window
	global string $gMainWindow;
	string $dynamicaMainMenu = `menu -l "Dynamica" -to 1 -p $gMainWindow`;
	menuItem -l "Dynamica Window" -ann "Open the main Dynamica window" -c "dynamicaUI_createWindow()" -fi "dynamicaWindow.xpm" $dynamicaMainMenu;
	menuItem -d 1 $dynamicaMainMenu;
	menuItem -l "Help" -ann "View the wiki online" -c "system(\"load http://bulletphysics.org/mediawiki-1.5.8/index.php/Maya_Dynamica_Plugin\")" $dynamicaMainMenu;

	//initial settings
	$dynamicaUI_startFrame = `playbackOptions -q -min`; //init start frame
	dynamicaUI_onPluginLoad(); //init script jobs
	playbackOptions -e -playbackSpeed 0 -maxPlaybackSpeed 1; //set playback options
	$dynamicaUI_bakeStartFrame = `playbackOptions -q -min`;
	$dynamicaUI_bakeEndFrame = `playbackOptions -q -max`;
	dynamicaUI_createShelf();
	
	print("Loading Dynamica plugin...complete.\n");
}
    
//shelf
global proc dynamicaUI_createShelf()
{
	global string $gShelfTopLevel;
	string $shelf = "Dynamica";
	string $dynamicaShelf;
	
	if ( `shelfLayout -ex $shelf` )
	{
		$dynamicaShelf = $shelf;
		string $shelfButtons[] = `shelfLayout -q -ca $shelf`;
		for ( $b in $shelfButtons ) deleteUI $b;
	} 
	else 
	{
		// Create the shelf under the global shelf parent.
		$dynamicaShelf = `shelfLayout -p $gShelfTopLevel $shelf`;
	}
	
	shelfButton -i "dynamicaWindow.xpm" -c "dynamicaUI_createWindow" -ann "Open Main Dynamica Window" -p $dynamicaShelf;
	
	shelfButton -i "dynamicaVoronoiShatter.xpm" 
		-c "dynamicaUI_voronoiShatter($dynamicaUI_crackWidth))" -ann "Shatter a mesh into voronoi fragments" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreateActiveSphere.xpm" 
		-c "dynamicaUI_createRigidBody(true, 5)" -ann "Create an active sphere rigid body" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreateActiveBox.xpm" 
		-c "dynamicaUI_createRigidBody(true, 4)" -ann "Create an active box rigid body" -p $dynamicaShelf;
	// shelfButton -i "dynamicaCreateActiveCylinder.xpm" 
		// -c "dynamicaUI_createRigidBody(true, 5)" -ann "Create an active cylinder rigid body" -p $dynamicaShelf;
	// shelfButton -i "dynamicaCreateActiveCapsule.xpm" 
		// -c "dynamicaUI_createRigidBody(true, 4)" -ann "Create an active capsule rigid body" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreateActiveHull.xpm" 
		-c "dynamicaUI_createRigidBody(true, 0)" -ann "Create active hull rigid bodies" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreateActiveMesh.xpm"
		-c "dynamicaUI_createRigidBody(true, 1)" -ann "Create active mesh rigid bodies" -p $dynamicaShelf;
		
	shelfButton -i "dynamicaCreatePassiveSphere.xpm" 
		-c "dynamicaUI_createRigidBody(false, 5)" -ann "Create passive sphere rigid body" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreatePassiveBox.xpm" 
		-c "dynamicaUI_createRigidBody(false, 4)" -ann "Create passive box rigid body" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreatePassiveHull.xpm" 
		-c "dynamicaUI_createRigidBody(false, 0)" -ann "Create passive hull rigid bodies" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreatePassiveMesh.xpm" 
		-c "dynamicaUI_createRigidBody(false, 1)" -ann "Create passive mesh rigid bodies" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreatePassivePlane.xpm" 
		-c "dynamicaUI_createRigidBody(false, 6)" -ann "Create passive plane rigid body" -p $dynamicaShelf;

	shelfButton -i "dynamicaCreateNailConstraint.xpm" 
		-c "dynamicaUI_createConstraint(0)" -ann "Create a breakable nail constraint" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreateHingeConstraint.xpm" 
		-c "dynamicaUI_createConstraint(1)" -ann "Create a breakable hinge constraint" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreateSliderConstraint.xpm" 
		-c "dynamicaUI_createConstraint(2)" -ann "Create a breakable slider constraint" -p $dynamicaShelf;
	shelfButton -i "dynamicaCreate6dofConstraint.xpm" 
		-c "dynamicaUI_createConstraint(3)" -ann "Create a breakable 6dof constraint" -p $dynamicaShelf;
	// shelfButton -i "dynamicaCreateConetwistConstraint.xpm" 
		// -c "dynamicaUI_createConstraint(3)" -ann "Create a breakable cone twist constraint" -p $dynamicaShelf;
		
	// shelfButton -i "dynamicaActivateX.xpm" 
		// -c "dynamicaUI_activateAxis(0)" -ann "Activate selected rigid bodies along the +X axis" -p $dynamicaShelf;
	// shelfButton -i "dynamicaActivate-X.xpm" 
		// -c "dynamicaUI_activateAxis(1)" -ann "Activate selected rigid bodies along the -X axis" -p $dynamicaShelf;
	// shelfButton -i "dynamicaActivateY.xpm" 
		// -c "dynamicaUI_activateAxis(2)" -ann "Activate selected rigid bodies along the +Y axis" -p $dynamicaShelf;
	// shelfButton -i "dynamicaActivate-Y.xpm" 
		// -c "dynamicaUI_activateAxis(3)" -ann "Activate selected rigid bodies along the -Y axis" -p $dynamicaShelf;
	// shelfButton -i "dynamicaActivateZ.xpm" 
		// -c "dynamicaUI_activateAxis(4)" -ann "Activate selected rigid bodies along the +Z axis" -p $dynamicaShelf;
	// shelfButton -i "dynamicaActivate-Z.xpm" 
		// -c "dynamicaUI_activateAxis(5)" -ann "Activate selected rigid bodies along the -Z axis" -p $dynamicaShelf;
		
	// shelfButton -i "dynamicaActivateRadial.xpm" 
		// -c "dynamicaUI_activateAxis(6)" -ann "Activate selected rigid bodies outwards" -p $dynamicaShelf;
	// shelfButton -i "dynamicaActivateRadialIn.xpm" 
		// -c "dynamicaUI_activateAxis(7)" -ann "Activate selected rigid bodies inwards" -p $dynamicaShelf;
	// shelfButton -i "dynamicaActivateChain.xpm" 
		// -c "dynamicaUI_activateAxis(8)" -ann "Chain activate selected rigid bodies" -p $dynamicaShelf;
		
	// shelfButton -i "dynamicaUnactivate.xpm" 
		// -c "dynamicaUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies active (restores default behavior)" -p $dynamicaShelf;
	// shelfButton -i "dynamicaMakePassive.xpm" 
		// -c "dynamicaUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies passive" -p $dynamicaShelf;
	// shelfButton -i "dynamicaSetInitialState.xpm" 
		// -c "dynamicaUI_setInitialState(0)" -ann "Set current state to initial state" -p $dynamicaShelf;
	// shelfButton -i "dynamicaClearInitialState.xpm" 
		// -c "dynamicaUI_setInitialState(1)" -ann "Restore original initial state" -p $dynamicaShelf;
		
	// shelfButton -i "dynamicaBakeSelected.xpm" 
		// -c "$dynamicaUI_bakeAll = 0; dynamicaUI_bakeRigidBodies()" -ann "Bake Selected Rigid Bodies" -p $dynamicaShelf;
	// shelfButton -i "dynamicaBakeAll.xpm" 
		// -c "$dynamicaUI_bakeAll = 1; dynamicaUI_bakeRigidBodies()" -ann "Bake All Rigid Bodies" -p $dynamicaShelf;
	
	shelfButton -i "dynamicaHelp.xpm" -c "system(\"load http://bulletphysics.org/mediawiki-1.5.8/index.php/Maya_Dynamica_Plugin\")" 
		-ann "View Online Documentation" -p $dynamicaShelf;
	// shelfButton -i "dynamicaTools.xpm" -c "dynamicaUI_tools()" -ann "Open Main Dynamica Window" -p $dynamicaShelf;
}

//UI
global proc dynamicaUI_createWindow()
{
	global string $dynamicaUI_window;
	global string $dynamicaUI_tabs;
	global string $dynamicaUI_helpLine;

	if ( `window -ex $dynamicaUI_window` )
	{
		showWindow $dynamicaUI_window; 
		return;
	}
	
	dSolver; //create dSolver node if necessary

	$dynamicaUI_window = `window -s 1 -t "Dynamica - powered by Bullet" -in "Dynamica"`;
	string $mainForm = `formLayout`;
	$dynamicaUI_tabs = `tabLayout -imw 5 -imh 5 -scr 0`;
	
	formLayout -e 
		-af $dynamicaUI_tabs "top" 0 -af $dynamicaUI_tabs "left" 0 
		-af $dynamicaUI_tabs "bottom" 0 -af $dynamicaUI_tabs "right" 0 
	$mainForm;
	
	string $mainTab = dynamicaUI_createMainTab();
	string $controlTab = dynamicaUI_createControlTab();
	string $bakeTab = dynamicaUI_createBakeTab();
	string $solverTab = dynamicaUI_createOptionsTab();
	string $helpTab = dynamicaUI_createHelpTab();

	tabLayout -e 
		-tl $mainTab "Create" 
		-tl $controlTab "Control" 
		-tl $bakeTab "Bake"
		-tl $solverTab "Options"
		-tl $helpTab "Help"
	$dynamicaUI_tabs;
	
	setParent ..;
	string $frame = `frameLayout -lv 0`;
	$dynamicaUI_helpLine = `textField -ed 0 -bgc 0.8 0.9 0.8 -tx "Dynamica main window loaded"`;
	
	formLayout -e
		-an $frame  "top"
		-af $frame  "left"   0
		-af $frame  "bottom" 0
		-af $frame  "right"  0
	$mainForm;

	showWindow $dynamicaUI_window;
	window -e -wh 500 480 $dynamicaUI_window;
}

global proc dynamicaUI_tools()
{
	source "dynamicaUITools";
	dynamicaUI_addTools();
}

global proc string dynamicaUI_createMainTab()
{
	global float $dynamicaUI_crackWidth = 0;
	//collision shape types: 0 = Hull, 1 = Mesh, 2 = Cylinder, 3 = Capsule, 4 = Box, 5 = Sphere, 6 = Plane, 7 = Bvh
	
	string $mainForm = `columnLayout -adj 1`;
	
		dynamicaUI_createFrame("Pre-fracture Mesh", "", 0, 0);
			rowLayout -nc 2;
				columnLayout -w 100;
					iconTextButton -st "iconAndTextVertical" -l "Voronoi Shatter" -w 85 -i "dynamicaVoronoiShatter.xpm"
						-c "dynamicaUI_voronoiShatter($dynamicaUI_crackWidth)" -ann "Shatter a mesh into voronoi fragments";
				setParent ..;
				columnLayout -w 350;
					text -align "left" -l "First select a mesh, then select particles. \nIf any particles intersect the mesh, voronoi fragments will be created.";
				setParent ..;
			setParent ..;
		setParent ..;
		
		dynamicaUI_createFrame("Active Rigid Bodies", "Active rigid bodies are controlled by the simulation solver and react to gravity, collisions, and fields.", 0, 0);
			rowLayout -nc 6;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "dynamicaCreateActiveSphere.xpm" 
					-c "dynamicaUI_createRigidBody(true, 5)" -ann "Create an active sphere rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "dynamicaCreateActiveBox.xpm" 
					-c "dynamicaUI_createRigidBody(true, 4)" -ann "Create an active box rigid body";

				// iconTextButton -st "iconAndTextVertical" -l "Cylinder" -w 75 -i "dynamicaCreateActiveCylinder.xpm"
					// -c "dynamicaUI_createRigidBody(true, 1)" -ann "Create an active cylinder rigid body";
					
				// iconTextButton -st "iconAndTextVertical" -l "Capsule" -w 75 -i "dynamicaCreateActiveCapsule.xpm"
					// -c "dynamicaUI_createRigidBody(true, 1)" -ann "Create an active capsule rigid body";
					
				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "dynamicaCreateActiveHull.xpm" 
					-c "dynamicaUI_createRigidBody(true, 0)" -ann "Create active hull rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "dynamicaCreateActiveMesh.xpm"
					-c "dynamicaUI_createRigidBody(true, 1)" -ann "Create active mesh rigid bodies from selection";
			setParent ..;
		setParent ..;

		dynamicaUI_createFrame("Passive Rigid Bodies", "Passive rigid bodies do not react to gravity or fields, but are included in collisions.\nIf passive rigid bodies are keyed and moving, they are considered kinematic - active bodies will collide and react accordingly.", 0, 0);
			rowLayout -nc 6;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "dynamicaCreatePassiveSphere.xpm" 
					-c "dynamicaUI_createRigidBody(false, 5)" -ann "Create a passive sphere rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "dynamicaCreatePassiveBox.xpm" 
					-c "dynamicaUI_createRigidBody(false, 4)" -ann "Create a passive box rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "dynamicaCreatePassiveHull.xpm" 
					-c "dynamicaUI_createRigidBody(false, 0)" -ann "Create passive hull rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "dynamicaCreatePassiveMesh.xpm" 
					-c "dynamicaUI_createRigidBody(false, 1)" -ann "Create passive mesh rigid bodies from selection";

				// iconTextButton -st "iconAndTextVertical" -l "BvhMesh" -w 75 -i "dynamicaCreatePassiveBvhMesh.xpm" 
					// -c "dynamicaUI_createRigidBody(false, 1)" -ann "Create passive Bvh mesh rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Plane" -w 75 -i "dynamicaCreatePassivePlane.xpm" 
					-c "dynamicaUI_createRigidBody(false, 6)" -ann "Create a passive plane rigid body";
			setParent ..;
		setParent ..;

		dynamicaUI_createFrame("Active Rigid Body Arrays", "Active rigid body arrays are collections of like-shaped active rigid bodies.", 0, 0);
			rowLayout -nc 5;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "dynamicaCreateActiveSphereArray.xpm"
					-c "dynamicaUI_createRigidBodyArray(true, 5)" -ann "Create an active sphere rigid body array";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "dynamicaCreateActiveBoxArray.xpm" 
					-c "dynamicaUI_createRigidBodyArray(true, 4)" -ann "Create an active box rigid body array";

				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "dynamicaCreateActiveHullArray.xpm" 
					-c "dynamicaUI_createRigidBodyArray(true, 0)" -ann "Create an active hull rigid body array from selection";

				iconTextButton -style "iconAndTextVertical" -label "Mesh" -w 75 -i "dynamicaCreateActiveMeshArray.xpm" 
					-c "dynamicaUI_createRigidBodyArray(true, 1)" -ann "Create an active mesh rigid body array from selection";
			setParent ..;
		setParent ..;

		// dynamicaUI_createFrame("Passive Rigid Body Arrays", "Passive rigid body arrays are collections of like-shaped passive rigid bodies.", 0, 0);
			// rowLayout -nc 6;
				// iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "dynamicaCreatePassiveSphereArray.xpm" 
					// -c "dynamicaUI_createRigidBodyArray(false, 5)" -ann "Create an passive sphere rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "dynamicaCreatePassiveBoxArray.xpm" 
					// -c "dynamicaUI_createRigidBodyArray(false, 4)" -ann "Create an passive box rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "dynamicaCreatePassiveHullArray.xpm" 
					// -c "dynamicaUI_createRigidBodyArray(false, 0)" -ann "Create an passive hull rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "dynamicaCreatePassiveMeshArray.xpm" 
					// -c "dynamicaUI_createRigidBodyArray(false, 1)" -ann "Create an passive mesh rigid body array from selection";

				// iconTextButton -style "iconAndTextVertical" -l "BvhMesh" -w 75 -i "dynamicaCreatePassiveBvhMeshArray.xpm" 
					// -c "dynamicaUI_createRigidBodyArray(false, 1)" -ann "Create an passive Bvh mesh rigid body array from selection";

				// iconTextButton -style "iconAndTextVertical" -l "Plane" -w 75 -i "dynamicaCreatePassivePlaneArray.xpm" 
					// -c "dynamicaUI_createRigidBodyArray(false, 6)" -ann "Create an passive plane rigid body array";
			// setParent ..;
		// setParent ..;

		dynamicaUI_createFrame("Constraints", "Constraints inhibit the natural (unconstrained) behavior of an active rigid body.\nConstraints require at least one rigid body to be selected. Rigid bodies can be influenced by multiple constraints.", 0, 0);
			rowLayout -nc 5;
				iconTextButton -st "iconAndTextVertical" -l "Nail" -w 75 -i "dynamicaCreateNailConstraint.xpm" 
					-c "dynamicaUI_createConstraint(0)" -ann "Create a breakable nail constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "Hinge" -w 75 -i "dynamicaCreateHingeConstraint.xpm" 
					-c "dynamicaUI_createConstraint(1)" -ann "Create a breakable hinge constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "Slider" -w 75  -i "dynamicaCreateSliderConstraint.xpm" 
					-c "dynamicaUI_createConstraint(2)" -ann "Create a breakable slider constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "6Dof" -w 75 -i "dynamicaCreate6dofConstraint.xpm" 
					-c "dynamicaUI_createConstraint(3)" -ann "Create a breakable 6dof constraint";
	
				// iconTextButton -st "iconAndTextVertical" -l "ConeTwist" -w 75 -i "dynamicaCreateConeTwistConstraint.xpm" 
					// -c "dynamicaUI_createConeTwistConstraint" -ann "Create a cone twist constraint";
			setParent ..;
		setParent ..;
	setParent ..;
	
	return $mainForm;
}

global proc string dynamicaUI_createControlTab() 
{
	global float $dynamicaUI_activeStartFrame = 24;
	global float $dynamicaUI_activeEndFrame = 48;
	global int $dynamicaUI_activateAxis = 0; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain

	string $mainForm = `columnLayout -adj 1`;

		dynamicaUI_createFrame("Frame Range For Rigid Body Control", "Selected rigid bodies will become active during this range", 0, 0);
			rowLayout -nc 2;
				floatField -pre 3 -w 50 -v $dynamicaUI_activeStartFrame -ann "Activation range start frame"
					-cc "$dynamicaUI_activeStartFrame = `floatField -q -v activateStart`" activateStart;
				floatField -pre 3 -w 50 -v $dynamicaUI_activeEndFrame -ann "Activation range end frame"
					-cc "$dynamicaUI_activeEndFrame = `floatField -q -v activateEnd`" activateEnd;
			setParent ..;
		setParent ..;

		dynamicaUI_createFrame("Make Rigid Bodies Active Along The X, Y, or Z Axis", "Make selected rigid bodies active along a world axis.", 0, 0);
			rowLayout -nc 6;
				iconTextButton -st "iconAndTextVertical" -l "+X Axis" -w 75 -i "dynamicaActivateX.xpm" 
					-c "dynamicaUI_activateAxis(0)" -ann "Activate selected rigid bodies along the +X axis";
				iconTextButton -st "iconAndTextVertical" -l "-X Axis" -w 75 -i "dynamicaActivate-X.xpm" 
					-c "dynamicaUI_activateAxis(1)" -ann "Activate selected rigid bodies along the -X axis";
				iconTextButton -st "iconAndTextVertical" -l "+Y Axis" -w 75 -i "dynamicaActivateY.xpm" 
					-c "dynamicaUI_activateAxis(2)" -ann "Activate selected rigid bodies along the +Y axis";
				iconTextButton -st "iconAndTextVertical" -l "-Y Axis" -w 75 -i "dynamicaActivate-Y.xpm" 
					-c "dynamicaUI_activateAxis(3)" -ann "Activate selected rigid bodies along the -Y axis";
				iconTextButton -st "iconAndTextVertical" -l "+Z Axis" -w 75 -i "dynamicaActivateZ.xpm" 
					-c "dynamicaUI_activateAxis(4)" -ann "Activate selected rigid bodies along the +Z axis";
				iconTextButton -st "iconAndTextVertical" -l "-Z Axis" -w 75 -i "dynamicaActivate-Z.xpm" 
					-c "dynamicaUI_activateAxis(5)" -ann "Activate selected rigid bodies along the -Z axis";
			setParent ..;
		setParent ..;
		
		dynamicaUI_createFrame("Make Rigid Bodies Active In A Radial Or Chain Pattern", "Make selected rigid bodies active in a radial or chain pattern, starting with the active object in the selection.", 0, 0);
			rowLayout -nc 3;
				iconTextButton -st "iconAndTextVertical" -l "Outward" -w 75 -i "dynamicaActivateRadial.xpm" 
					-c "dynamicaUI_activateAxis(6)" -ann "Radially activate selected rigid bodies outwards";
				iconTextButton -st "iconAndTextVertical" -l "Inward" -w 75 -i "dynamicaActivateRadialIn.xpm" 
					-c "dynamicaUI_activateAxis(7)" -ann "Radially activate selected rigid bodies inwards";
				iconTextButton -st "iconAndTextVertical" -l "Daisy Chain" -w 75 -i "dynamicaActivateChain.xpm" 
					-c "dynamicaUI_activateAxis(8)" -ann "Chain activate selected rigid bodies";
			setParent ..;
		setParent ..;
		
		dynamicaUI_createFrame("Configure & Modify Rigid Bodies (frame range ignored)", "Restore default active behavior, convert to passive, or set the initial state of selected rigid bodies.", 0, 0);
			rowLayout -nc 4;
				iconTextButton -st "iconAndTextVertical" -l "Make Active" -w 75 -i "dynamicaUnactivate.xpm" 
					-c "dynamicaUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies active (restores default behavior)";
				iconTextButton -st "iconAndTextVertical" -l "Make Passive" -w 75 -i "dynamicaMakePassive.xpm" 
					-c "dynamicaUI_deactivateRigidBodies(1)" -ann "Make selected rigid bodies passive";
				iconTextButton -st "iconAndTextVertical" -l "Set Initial State" -w 85 -i "dynamicaSetInitialState.xpm" 
					-c "dynamicaUI_setInitialState(0)" -ann "Set current state to initial state";
				iconTextButton -st "iconAndTextVertical" -l "Clear Initial State" -w 85 -i "dynamicaClearInitialState.xpm" 
					-c "dynamicaUI_setInitialState(1)" -ann "Restore original initial state";
			setParent ..;
		setParent ..;
	setParent ..;

	return $mainForm;
}

global proc string dynamicaUI_createBakeTab() 
{
	global int $dynamicaUI_deleteEmptyNodes = 1;
	global int $dynamicaUI_deleteBakeHistory = 1;
	global int $dynamicaUI_deleteStaticChannels = 1;
	global int $dynamicaUI_optimizeChannels = 1;
	global int $dynamicaUI_bakeAll = 1;
	global float $dynamicaUI_bakeStartFrame;
	global float $dynamicaUI_bakeEndFrame;
	
	float $start = `playbackOptions -q -min`;
	float $end = `playbackOptions -q -max`;

	string $mainForm = `columnLayout -adj 1`;
		dynamicaUI_createFrame("Set The Frame Range To Bake", "Set the starting and ending frames for baking.", 0, 0);
			rowLayout -nc 2;
				floatField -pre 3 -w 50 -v $start
					-cc "if (`floatField -q -v bakeStart` > `floatField -q -v bakeEnd`) floatField -e -v (`floatField -q -v bakeStart`) bakeEnd;$dynamicaUI_bakeStartFrame = `floatField -q -v bakeStart`" bakeStart;
				floatField -pre 3 -w 50 -v $end
					-cc "if (`floatField -q -v bakeStart` > `floatField -q -v bakeEnd`) floatField -e -v (`floatField -q -v bakeEnd`) bakeStart;$dynamicaUI_bakeEndFrame = `floatField -q -v bakeEnd`" bakeEnd;
				$dynamicaUI_bakeStartFrame = `floatField -q -v bakeStart`;
				$dynamicaUI_bakeEndFrame = `floatField -q -v bakeEnd`;
			setParent ..;
		setParent ..;
		
		dynamicaUI_createFrame("Bake Selected Or All Rigid Bodies", "Bake keyframe data for selected or all rigid bodies in the scene.", 0, 0);
			rowLayout -nc 2;
				iconTextButton -st "iconAndTextVertical" -l "Bake Selected" -w 75 -i "dynamicaBakeSelected.xpm" 
					-c "$dynamicaUI_bakeAll = 0; dynamicaUI_bakeRigidBodies()" -ann "Bake Selected Rigid Bodies";
				iconTextButton -st "iconAndTextVertical" -l "Bake All" -w 75 -i "dynamicaBakeAll.xpm" 
					-c "$dynamicaUI_bakeAll = 1; dynamicaUI_bakeRigidBodies()" -ann "Bake All Rigid Bodies";
			setParent ..;
		setParent ..;
		
		dynamicaUI_createFrame("Bake Options", "Enabling these options can dramatically reduce scene size and overhead.", 1, 1);
			columnLayout;
				checkBox -l "Optimize Channels (Recommended)" -v $dynamicaUI_optimizeChannels -ann "Remove unneccassary keyframes (significantly reduces data and file size)" 
					-cc "$dynamicaUI_optimizeChannels  = `checkBox -q -v bakeOptimize`" bakeOptimize;
				checkBox -l "Delete History (Recommended)" -v $dynamicaUI_deleteBakeHistory -ann "Delete history on all baked objects" 
					-cc "$dynamicaUI_deleteBakeHistory  = `checkBox -q -v bakeHistory`" bakeHistory;
				checkBox -l "Delete Empty Nodes (Recommended)" -v $dynamicaUI_deleteEmptyNodes -ann "Remove empty and orphaned nodes" 
					-cc "$dynamicaUI_deleteEmptyNodes  = `checkBox -q -v bakeEmpty`" bakeEmpty;
			setParent ..;
		setParent ..;
	setParent ..;

	return $mainForm;
}

global proc string dynamicaUI_createOptionsTab()
{	
	global string $dynamicaUI_STsolverType;
	global string $dynamicaUI_STgravityX;
	global string $dynamicaUI_STgravityY;
	global string $dynamicaUI_STgravityZ;
	global string $dynamicaUI_STenabled;
	global string $dynamicaUI_STsplitImpulse;
	global string $dynamicaUI_STsubsteps;
	global string $dynamicaUI_STphysicsrate;
	global string $dynamicaUI_STcollisionMargin;
	global string $dynamicaUI_activateSet;
	global float $dynamicaUI_collisionMargin;
	global float $dynamicaUI_crackWidth;
	global int $dynamicaUI_createActivateSet = 1;
	
	string $mainForm = `columnLayout -adj 1`;
	
		dynamicaUI_createFrame("Solver Options", "", 1, 0);
			columnLayout;
				rowLayout -nc 2;
					columnLayout -w 220;
						text -al "left" -fn "boldLabelFont" -l "Gravity" -ann "Direction and magnitude of gravity in the simulation.";
						float $gravity[] = `getAttr dSolver1.gravity`;
						rowLayout -nc 3;
							$dynamicaUI_STgravityX = `floatField -pre 3 -w 50 -v $gravity[0]`;
							$dynamicaUI_STgravityY = `floatField -pre 3 -w 50 -v $gravity[1]`;
							$dynamicaUI_STgravityZ = `floatField -pre 3 -w 50 -v $gravity[2]`;
							connectControl $dynamicaUI_STgravityX dSolver1.gravityX;
							connectControl $dynamicaUI_STgravityY dSolver1.gravityY;
							connectControl $dynamicaUI_STgravityZ dSolver1.gravityZ;
						setParent ..;
					setParent ..;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Physics Framerate (Hertz)";
						int $physicsrate= `getAttr dSolver1.physicsrate`; 
						$dynamicaUI_STphysicsrate = `intField -v $physicsrate -w 50 -ann "Default is 60. Higher values \"speed up\" simulation"`;
						connectControl $dynamicaUI_STphysicsrate dSolver1.physicsrate;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout -w 220;
						text -al "left" -fn "boldLabelFont" -l "Substeps";
						int $substeps = `getAttr dSolver1.substeps`; 
						$dynamicaUI_STsubsteps = `intField -v $substeps -w 50 
							-ann "Number of times the simulation is evaluated 'between' each frame step on the timeline.\nThe default value of 1 should work for most simulations."`;
						connectControl $dynamicaUI_STsubsteps dSolver1.substeps;
					setParent ..;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Split Impulse";
						int $enabled = `getAttr dSolver1.splitImpulse`;
						$dynamicaUI_STsplitImpulse = `checkBox -l "Enabled" -v $enabled 
							-ann "Enabling Split Impulse will allow the solver to apply positional corrections when deep collision penetrations occur.\nThese corrections do not affect resulting velocities."`;
						connectControl $dynamicaUI_STsplitImpulse dSolver1.splitImpulse;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Solver State";
						int $enabled = `getAttr dSolver1.enabled`;
						$dynamicaUI_STenabled = `checkBox -l "Enabled" -v $enabled 
							-ann "Toggles the state of the solver - like an on/off switch."`;
						connectControl $dynamicaUI_STenabled dSolver1.enabled;
					setParent ..;
					columnLayout;
						//
					setParent ..;
				setParent ..;
			setParent ..;
		setParent ..;
		
		dynamicaUI_createFrame("Tool Options", "", 1, 0);
			columnLayout;
				rowLayout -nc 2;
					columnLayout -w 220;
						text -al "left" -fn "boldLabelFont" -l "Shatter Crack Width";
						floatField -pre 3 -w 50 -min 0 -v $dynamicaUI_crackWidth -cc "$dynamicaUI_crackWidth = `floatField -q -v voroCrack`" voroCrack;
					setParent ..;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Colision Margin (creation only)";
						$dynamicaUI_collisionMargin = `getAttr dSolver1.collisionMargin`; 
						$dynamicaUI_STcollisionMargin = `floatField -pre 3 -w 50 -v $dynamicaUI_collisionMargin 
							-ann "The gap around each collision shape used for collision detection.\nThis value only effects Hull and Mesh rigid bodies during creation. Default is 0.040." 
							-cc "$dynamicaUI_collisionMargin = `floatField -q -v $dynamicaUI_STcollisionMargin`"`;
						connectControl $dynamicaUI_STcollisionMargin dSolver1.collisionMargin;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 1;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Disable Collisions Between Constrained Bodies (creation only)";
						int $enabled = `getAttr dSolver1.disableCollisionsBetweenLinkedBodies`;
						$dynamicaUI_disableCollisionsBetweenLinkedBodies = `checkBox -l "Enabled" -v $enabled 
							-ann "Controls the collisions of rigid bodies which share a constraint. This only effects constraints during creation."`;
						connectControl $dynamicaUI_disableCollisionsBetweenLinkedBodies dSolver1.disableCollisionsBetweenLinkedBodies;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Create Control Sets";
						$dynamicaUI_activateSet = `checkBox -l "Enabled" -v $dynamicaUI_createActivateSet 
							-ann "Creates quick select sets containing rigid bodies modified by activation controls." 
							-cc "$dynamicaUI_createActivateSet = `checkBox -q -v $dynamicaUI_activateSet`"`;
					setParent ..;
					columnLayout;
						//
					setParent ..;
				setParent ..;
				
				separator -h 10;
				button -l "Toggle Advanced Tools Tab" -c "dynamicaUI_tools()";
			setParent ..;
		setParent ..;
		
	setParent ..;

	return $mainForm;
}

global proc string dynamicaUI_createHelpTab()
{	
	string $mainForm = `columnLayout -adj 1`;
		dynamicaUI_createFrame("Documentation & Resources", "View the online wiki documentation or bulletphysics.org", 0, 0);
			rowLayout -nc 2;
				iconTextButton -st "iconAndTextVertical" -l "Online Help" -w 75 -i "dynamicaHelp.xpm" 
					-c "system(\"load http://bulletphysics.org/mediawiki-1.5.8/index.php/Maya_Dynamica_Plugin\")" -ann "View Online Documentation";
				iconTextButton -st "iconAndTextVertical" -l "bulletphysics.org" -w 90 -i "dynamicaBulletWebsite.xpm" 
					-c "system(\"load http://bulletphysics.org\")" -ann "Visit bulletphysics.org";
			setParent ..;
		setParent ..;
		
		// dynamicaUI_createFrame("Example Scenes", "See Dynamica in action with these demonstration scenes", 0, 0);
			// rowLayout -nc 5;
				// iconTextButton -st "iconAndTextVertical" -l "Demo 1" -w 75 -i "" 
					// -c "" -ann "";
				// iconTextButton -st "iconAndTextVertical" -l "Demo 2" -w 75 -i "" 
					// -c "" -ann "";
				// iconTextButton -st "iconAndTextVertical" -l "Demo 3" -w 75 -i "" 
					// -c "" -ann "";
				// iconTextButton -st "iconAndTextVertical" -l "Demo 4" -w 75 -i "" 
					// -c "" -ann "";
				// iconTextButton -st "iconAndTextVertical" -l "Demo 5" -w 75 -i "" 
					// -c "" -ann "";
			// setParent ..;
		// setParent ..;
		
		// dynamicaUI_createFrame("Feature Overview", "", 0, 0);
			// scrollLayout -h 235;
				// string $helpText = dynamicaUI_loadHelp();
				// string $text = `text -al "left" -ww 1 -l $helpText`;
			// setParent ..;
		// setParent ..;
			
		dynamicaUI_createFrame("Credits", "", 0, 0);
			text -al "left" -l "Original Plugin: Walt Disney Studios";
			text -al "left" -l "Original Author: Nicola Candussi";
			text -al "left" -l "Modified By: Roman Ponomarev";
			text -al "left" -l "Tools, Features, & Maintenance: Michael Baker";
			text -al "left" -l "UI Design: Michael Baker & Erwin Coumans";
			text -al "left" -l "Bullet Physics Framework: Erwin Coumans";
			setParent ..;
		setParent ..;
		
	setParent ..;

	return $mainForm;
}

global proc string dynamicaUI_createFrame(string $label, string $annotation, int $collapsable, int $collapsed) 
{
	return `frameLayout -cll $collapsable -cl $collapsed -mh 3 -mw 6 -w 486 -bs "etchedIn" -l $label -ann $annotation`;
}

global proc string dynamicaUI_loadHelp()
{
	string $path = `file -query -location "dynamicaUI.mel"`;
	$path = strip(`substitute "dynamicaUI.mel" $path ""`);
	$path = `substitute "scripts" $path "doc"`;
	$path += "HELP.txt";

	int $fid = `fopen $path "r"`;
	string $line = `fgetline $fid`;
	string $fileData = $line;
	while (size($line) > 0)
	{
		$line =`fgetline $fid`;
		$fileData += $line;
	}
	fclose $fid;
	return $fileData;
}

global proc dynamicaUI_print(string $out, int $mode)
{
	//modes: 0 = print, 1 = warning, 2 = error
	global string $dynamicaUI_helpLine;
	
	if ($mode == 0)
	{
		if(`textField -ex $dynamicaUI_helpLine`) textField -e -bgc 0.8 0.9 0.8 -tx ("Dynamica: " + $out) $dynamicaUI_helpLine;
		print("Dynamica: " + $out + "\n");
	}
	else if ($mode == 1)
	{
		if(`textField -ex $dynamicaUI_helpLine`) textField -e -bgc 1.0 1.0 0.8 -tx ("Dynamica: " + $out) $dynamicaUI_helpLine;
		warning("Dynamica Warning: " + $out + "\n");
	}
	else if ($mode == 2)
	{
		if(`textField -ex $dynamicaUI_helpLine`) textField -e -bgc 1.0 0.6 0.6 -tx ("Dynamica: " + $out) $dynamicaUI_helpLine;
		error("Dynamica Error: " + $out + "\n");
	}
	refresh;
}

//procs
global proc dynamicaUI_voronoiShatter(float $crackWidth)
{
	python("import dg_voroPy as v");
	python("reload(v)");
	print $crackWidth;
	python( "v.doVoro(" + $crackWidth +", (" + 0.3 + "," + 0.6 + "," + 0.7 + "))");
}

global proc dynamicaUI_createRigidBody(int $activebody, int $collisionShapeType)
{
	//collision shape types: 0 = Hull, 1 = Mesh, 2 = Cylinder, 3 = Capsule, 4 = Box, 5 = Sphere, 6 = Plane
	global float $dynamicaUI_startFrame;
	global float $dynamicaUI_collisionMargin;
	float $mass = 1; 
	string $meshLayer = "DynamicaInputMeshes";
	string $rbLayer = "DynamicaRigidBodies";
	string $obSelection[] = `ls -sl`;
	string $selection[];
	string $newBodies[];
	string $rbGroup;
	string $meshGroup;
	string $margin;
	int $bodyCount = 0;
	int $makeCollisionShape = 1;
	float $collisionMargin = $dynamicaUI_collisionMargin * 1.75; //compensate for descrepancy between Maya vertex shift and Bullet planar shift
	
	for ($o in $obSelection) mbDeleteShapeHistory($o); //clean shape history
	$selection = `ls -selection -dag -leaf -showType -type "geometry"`;
	
	if ($activebody == false) $mass = 0;
	
	dSolver; //create dSolver node if necessary
	
	//pick the selected object's transform only if we are creating a hull or a mesh
	if ($collisionShapeType == 0 || $collisionShapeType == 1) 
	{
		if (size($selection))
		{
			dynamicaUI_print("Creating Dynamica rigid bodies...", 0);
			refresh;
			//create groups and layers if necessary
			$rbGroup = `group -em -n dRigidBodies`;
			$meshGroup = `group -em -n dMeshes`;
			mbHideAndLockTransform($rbGroup);
			mbHideAndLockTransform($meshGroup);
			mbCreateLayer($meshLayer, 1);
			mbCreateLayer($rbLayer, 0);
			//setAttr ($rbLayer + ".shading") 0; //disable shading
		
			for ($i = 0; $i < size($selection) / 2; $i++)
			{
				string $marginShape;
				string $connectedCollisionShapes[] = `listConnections -s 1 -t dCollisionShape $selection[$i * 2]`;
				if(size($connectedCollisionShapes) > 0) $makeCollisionShape = 0;
				
				string $shapeTransforms[] = `listRelatives -p -f -pa $selection[$i * 2]`;

				if ($makeCollisionShape)
				{
					if (mbIsMesh($obSelection[$i]))
					{
						if (!mbIsKeyed($obSelection[$i])) //process transform if not keyed
						{
							mbFreezeScale($obSelection[$i]);
							mbUnFreezeTranslation($obSelection[$i]);
							
							//process collision margin if active
							if ($activebody) 
							{
								$dup = `duplicate $obSelection[$i]`;
								$marginShape = mbGetShape($dup[0]);
								setAttr ($marginShape + ".visibility") 0;
								$margin = mbDeflate($marginShape, $collisionMargin);
								parent -s -add $marginShape $obSelection[$i];
								delete $dup;
								delete -ch $obSelection[$i];
								string $shapes[] = mbGetShapes($obSelection[$i]);
								$marginShape = $shapes[1]; //update marginShape
							}
						}
						
						string $rigidBodyNode = `dRigidBody`;
						string $collisionShapeNode = `createNode dCollisionShape`;
						connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
						string $rigidBodyTransforms[] = `listRelatives -p $rigidBodyNode`;
						
						if ($selection[$i * 2 + 1] == "mesh") {
							connectAttr ($marginShape + ".message") ($collisionShapeNode + ".inShape");
							setAttr ($rigidBodyTransforms[0] + ".overrideEnabled") 1;
							setAttr ($rigidBodyTransforms[0] + ".overrideShading") 0;		
						}
						
						if (mbIsKeyed($obSelection[$i]))
						{
							warning($obSelection[$i] + "'s transform is keyed, creating kinematic collider...");
							$mass = 0;
							mbTransferKeys($obSelection[$i], $rigidBodyTransforms[0], 1);
						}
						
						setAttr ($rigidBodyNode + ".mass" ) $mass;
						setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;

						float $pos[]= `getAttr ($shapeTransforms[0] + ".translate")`;
						float $rot[]= `getAttr ($shapeTransforms[0] + ".rotate")`;

						setAttr ($rigidBodyTransforms[0] + ".translate") -typ double3 $pos[0] $pos[1] $pos[2];
						setAttr ($rigidBodyNode + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
						setAttr ($rigidBodyTransforms[0] + ".rotate") -typ double3 $rot[0] $rot[1] $rot[2];
						setAttr ($rigidBodyNode + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
						
						//store original position and rotation
						addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
						addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
						addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
						addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
						addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
						addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
						addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
						addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];
						
						//connect original mesh transform to rigid body transform
						connectAttr ($rigidBodyTransforms[0] + ".translate") ($shapeTransforms[0] + ".translate");
						connectAttr ($rigidBodyTransforms[0] + ".rotate") ($shapeTransforms[0] + ".rotate");
						connectAttr ($rigidBodyTransforms[0] + ".scale") ($shapeTransforms[0] + ".scale");
						
						$newBodies[$i] = $rigidBodyTransforms[0];
						
						//add to groups and layers
						mbAddToLayer($obSelection[$i], $meshLayer); //editDisplayLayerMembers -nr $meshLayer $shapeTransforms[0];
						mbAddToLayer($rigidBodyTransforms[0], $rbLayer);
						parent $obSelection[$i] $meshGroup;
						parent $rigidBodyTransforms[0] $rbGroup;
						$bodyCount++;
						
						refresh;
						//if ($activebody) mbUnflate($margin); //if active, restore shape
					}
					else
					{
						dynamicaUI_print($obSelection[$i] + " is not a Polymesh, rigid body not created!", 1);
					}
				}
				else
				{
					dynamicaUI_print($shapeTransforms[0] + " is already a rigid body", 1);
					//$newBodies[$i] = $shapeTransforms[0];
				}
				$makeCollisionShape = 1;
			}
			if ($bodyCount) dynamicaUI_print("Created " + $bodyCount + " rigid bodies. Find rigid bodies and source meshes in Outliner and Display Layers.", 0);
		}
		else
		{
			dynamicaUI_print("Unable to create rigid body(s), select Polymesh objects first...", 1);
		}
	} 
	else //create primitive
	{
		string $rigidBodyNode = `dRigidBody`;
		string $collisionShapeNode = `createNode dCollisionShape`;
		connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
		string $rigidBodyTransforms[] = `listRelatives -parent $rigidBodyNode`;

		setAttr ($rigidBodyNode + ".mass" ) $mass;
		setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
		
		float $pos[]= `getAttr ($rigidBodyTransforms[0] + ".translate")`;
		float $rot[]= `getAttr ($rigidBodyTransforms[0] + ".rotate")`;
						
		//store original position and rotation
		addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
		addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
		addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
		addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
		addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
		addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
		addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
		addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];

		$newBodies[0] = $rigidBodyTransforms[0];
		
		dynamicaUI_print("Created rigid body primitive: " + $rigidBodyNode, 0);
	}

	currentTime $dynamicaUI_startFrame; //force refresh
	select -r $newBodies;
}

global proc string dynamicaUI_createConstraint(int $constraintType)
{
	//0 = Nail, 1 = Hinge, 2 = Slider, 3 = 6Dof
	string $selection[] = `ls -sl`;
	string $constraintTransforms[];
	$selection = `listRelatives -s $selection`;
	string $constraintNode;
	string $newConstraintTransf;
	
	dSolver; //create dSolver node if necessary
	
	// check selection in scene : one or two rigidBodies should be selected
	int $selSize = size($selection);
	int $selOK = (($selSize == 1) || ($selSize == 2));

	if ($selSize > 2) //more than 2 objects selected
	{
		dynamicaUI_constrainMultiple($constraintType);
		return "";
	}
	
	for ($s in $selection) if(`nodeType $s` != "dRigidBody") $selOK = 0;
	
	if(!$selOK)
	{
		dynamicaUI_print("Select one or more rigid bodies to create a constraint.", 2);
		return "";
	}
	
	//create constraint node
	switch ($constraintType)
	{
		case 0:
			$constraintNode = `dNailConstraint`;
			break;
		case 1:
			$constraintNode = `dHingeConstraint`;
			break;
		case 2:
			$constraintNode = `dSliderConstraint`;
			break;
		case 3:
			$constraintNode = `dSixdofConstraint`;
			break;
	}
	
	setAttr ($constraintNode + ".disableCollide") `getAttr dSolver1.disableCollisionsBetweenLinkedBodies`;
	$constraintTransforms = `listRelatives -p $constraintNode`;
	$newConstraintTransf = $constraintTransforms[0];
	
	//connect to bodies
	if($selSize == 1)
	{
		connectAttr ($selection[0] + ".message") ($constraintNode + ".inRigidBodyA");
		string $rbTransform[] = `listRelatives -p $selection[0]`;
		float $posA[3] = `getAttr ($rbTransform[0] + ".translate")`;
		float $iWorldA[16] = `getAttr ($rbTransform[0] + ".worldMatrix")`;
		float $pivA[] = dynamicaUI_worldToObj($posA, $iWorldA);
		setAttr ($constraintNode + ".pivotInA") -typ float3 $pivA[0] $pivA[1] $pivA[2];
		setAttr ($newConstraintTransf + ".translate") -typ float3 $posA[0] $posA[1] $posA[2];
	}
	else
	{
		connectAttr ($selection[0] + ".message") ($constraintNode + ".inRigidBodyA");
		connectAttr ($selection[1] + ".message") ($constraintNode + ".inRigidBodyB");
		string $rbTransformA[] = `listRelatives -p $selection[0]`;
		string $rbTransformB[] = `listRelatives -p $selection[1]`;
		float $posA[] = `getAttr ($rbTransformA[0] + ".translate")`;
		float $posB[] = `getAttr ($rbTransformB[2] + ".translate")`;
		float $pivW[3];
		//move constraint to midpoint between each rigid body
		$pivW[0] = mbLerpScalar($posA[0], $posB[0], 0.5);
		$pivW[1] = mbLerpScalar($posA[1], $posB[1], 0.5);
		$pivW[2] = mbLerpScalar($posA[2], $posB[2], 0.5);
		float $iWorldA[16] = `getAttr ($rbTransformA[0] + ".worldMatrix")`;
		float $iWorldB[16] = `getAttr ($rbTransformB[0] + ".worldMatrix")`;
		float $pivA[] = dynamicaUI_worldToObj($pivW, $iWorldA);
		float $pivB[] = dynamicaUI_worldToObj($pivW, $iWorldB);
		setAttr ($constraintNode + ".pivotInA") -typ float3 $pivA[0] $pivA[1] $pivA[2];
		setAttr ($constraintNode + ".pivotInB") -typ float3 $pivB[0] $pivB[1] $pivB[2];
		setAttr ($newConstraintTransf + ".translate") -typ float3 $pivW[0] $pivW[1] $pivW[2];
	}
	select -r $newConstraintTransf;
	return $newConstraintTransf;
}

global proc dynamicaUI_constrainMultiple(int $constraintType)
{
	string $sel[] = `ls -sl`;
	string $selTmp[] = $sel;
	string $overlapping[];
	string $nearest[];
	string $newConstraint;
	string $constraintLayer = "DynamicaConstraints";
	string $constraintGroup;
	int $constraintCount = 0;

	//filter selection
	for ($s in $sel) if (!mbIsType($s, "dRigidBody")) select -d $s;
	
	$overlapping = mbGetOverlappingTransforms($sel);
	if (size($overlapping))
	{
		dynamicaUI_print("Spatial duplicates found and ignored.", 1);
		print("Dynamica: overlapping transforms ----------------- :\n");
		print($overlapping);
		select -d $overlapping;
	}

	$sel = `ls -sl`;
	if (size($sel) < 2)
	{
		select -r $selTmp;
		dynamicaUI_print("No constrainable rigid bodies in selection", 2);
		return;
	}
	else
	{
		dynamicaUI_print("Creating Dynamica Constraints...", 0);
		//create groups and layers if necessary
		$constraintGroup = `group -em -n dConstraints`;
		mbHideAndLockTransform($constraintGroup);
		mbCreateLayer($constraintLayer, 0);
	}
	
	//collect and sort RBs
	int $last = size($sel) - 1;
	$nearest = mbDaisyChainObjects($sel, $sel[$last], 0);
	
	for ($i=0;$i<size($nearest)-1;$i++)
	{
		if ($i < (size($nearest)-1)) select -r $nearest[$i] $nearest[$i+1];

		switch ($constraintType)
		{
			case 0:
				$newConstraint = dynamicaUI_createConstraint(0);
				break;
			case 1:
				$newConstraint = dynamicaUI_createConstraint(1);
				break;
			case 2:
				$newConstraint = dynamicaUI_createConstraint(2);
				break;
			case 3:
				$newConstraint = dynamicaUI_createConstraint(3);
				break;
		}
		$constraintCount++;
		mbAddToLayer($newConstraint, $constraintLayer);
		parent $newConstraint $constraintGroup;
		refresh;
	}
	
	dynamicaUI_print("Created " + $constraintCount + " constraints.", 0);
	clear($nearest);
	clear($sel);
	
}

global proc dynamicaUI_createRigidBodyArray(int $activebody, int $collisionShapeType)
{
	global float $dynamicaUI_startFrame;
	float $mass = 1;
	
	if ($activebody == false) $mass = 0;
	
	global int $dynamicaUI_createArrayUI_size[];
	global float $dynamicaUI_createArrayUI_offset[];

	if(`layoutDialog -title "Create Rigid Body Array" -ui "dynamicaUI_createArrayUI"` == "OK") {    
		string $selection[] = `ls -selection -dag -leaf -showType -type "geometry"`;

		//create dSolver node if necessary
		dSolver;

		string $rigidBodyArrayNode = `dRigidBodyArray`;
		string $collisionShapeNode = `createNode dCollisionShape`;
		connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyArrayNode + ".inCollisionShape");
		string $rigidBodyTransforms[] = `listRelatives -parent $rigidBodyArrayNode`;
		
		if(size($selection) != 0) {
			string $shapeTransforms[] = `listRelatives -parent $selection[0]`;
			if($selection[1] == "mesh") {
				connectAttr ($selection[0] + ".message") ($collisionShapeNode + ".inShape");
				hide $shapeTransforms[0];
			}
		}
		
		setAttr ($rigidBodyArrayNode + ".mass" ) $mass;
		setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
		
		select -r $rigidBodyTransforms[0];

		int $size[]= $dynamicaUI_createArrayUI_size;
		float $off[]= $dynamicaUI_createArrayUI_offset;
		float $x0[];
		$x0[0] = -0.5 * $size[0] * $off[0];
		$x0[1] = -0.5 * $size[1] * $off[1];
		$x0[2] = -0.5 * $size[2] * $off[2];
		setAttr ($rigidBodyArrayNode + ".numBodies") ($size[0] * $size[1] * $size[2]);
		for ($i = 0; $i < $size[0]; $i++) {
			for ($j = 0; $j < $size[1]; $j++) {
				for ($k = 0; $k < $size[2]; $k++) {
					setAttr ($rigidBodyArrayNode + ".initialPosition[" + string($i + $size[0] * $j + $size[0] * $size[1] * $k) + "]") ($x0[0] + $i * $off[0]) ($x0[1] + $j * $off[1]) ($x0[2] + $k * $off[2]);
				}
			}
		}  
		currentTime $dynamicaUI_startFrame; //force refresh		
	}
}

global proc dynamicaUI_createArrayUIdismissCB(string $button)
{
	global string $dynamicaUI_createArrayUI_sizeCT;
	global string $dynamicaUI_createArrayUI_offsetCT;

	global int $dynamicaUI_createArrayUI_size[];
	global float $dynamicaUI_createArrayUI_offset[];

	$dynamicaUI_createArrayUI_size = `intFieldGrp -query -value $dynamicaUI_createArrayUI_sizeCT`; 
	$dynamicaUI_createArrayUI_offset = `floatFieldGrp -query -value $dynamicaUI_createArrayUI_offsetCT`; 
	layoutDialog -dismiss $button;
}

global proc dynamicaUI_createArrayUI()
{
	global string $dynamicaUI_createArrayUI_sizeCT;
	global string $dynamicaUI_createArrayUI_offsetCT;

	// Get the dialog's formLayout.
	string $form = `setParent -q`;

	// layoutDialog's are not resizable, so hard code a size here,
	// to make sure all UI elements are visible.
	formLayout -e -width 400 $form;

	string $b1 = `button -l "OK"    -c "dynamicaUI_createArrayUIdismissCB(\"OK\")"`;
	string $b2 = `button -l "Cancel"-c "dynamicaUI_createArrayUIdismissCB(\"Cancel\")"`;

	$dynamicaUI_createArrayUI_sizeCT = `intFieldGrp -columnAlign 1 "left" -adj 1 -numberOfFields 3 -label "Array Size" -v1 3 -v2 3 -v3 3`;
	$dynamicaUI_createArrayUI_offsetCT = `floatFieldGrp -columnAlign 1 "left" -adj 1 -numberOfFields 3 -label "Array Offset" -v1 2.0 -v2 2.0 -v3 2.0`;

	formLayout -edit
	-attachForm            $dynamicaUI_createArrayUI_sizeCT   "top"    5
	-attachForm            $dynamicaUI_createArrayUI_sizeCT   "left"   5
	-attachNone            $dynamicaUI_createArrayUI_sizeCT   "bottom"
	-attachForm            $dynamicaUI_createArrayUI_sizeCT   "right"  5 

	-attachControl         $dynamicaUI_createArrayUI_offsetCT  "top"   5 $dynamicaUI_createArrayUI_sizeCT
	-attachForm            $dynamicaUI_createArrayUI_offsetCT  "left"   5
	-attachNone            $dynamicaUI_createArrayUI_offsetCT  "bottom"
	-attachForm            $dynamicaUI_createArrayUI_offsetCT   "right"  5 

	-attachControl         $b1  "top"   5 $dynamicaUI_createArrayUI_offsetCT
	-attachForm            $b1  "left"   5
	-attachNone            $b1  "bottom"
	-attachPosition        $b1  "right"  5 33

	-attachControl         $b2  "top"    5 $dynamicaUI_createArrayUI_offsetCT
	-attachPosition        $b2  "left"   5 33
	-attachNone            $b2  "bottom"
	-attachPosition        $b2  "right"  5 66

	$form;
}

global proc float[] dynamicaUI_worldToObj(float $pointW[], float $objToWorldMatrix[])
{
	float $result[];
	$result[0] = 0.0;
	$result[1] = 0.0;
	$result[2] = 0.0;
	float $offs[];
	if ( size($pointW) != 3 || size($objToWorldMatrix) != 16 )
	{
		warning("Point must be an array of 3 doubles and matrix must be an array of 16 doubles.");
		return $result;
	}
	for ($i = 0; $i < 3; $i++)
	{
		$offs[$i] = $pointW[$i] - $objToWorldMatrix[12 + $i];
	}
	for ($i = 0; $i < 3; $i++)
	{
		for ($j = 0; $j < 3; $j++)
		{
			$result[$i] += $objToWorldMatrix[$i * 4 + $j] * $offs[$j];
		}
	}
	return $result;
}

global proc dynamicaUI_activateAxis(int $axis)
{
	global int $dynamicaUI_activateAxis; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain
	$dynamicaUI_activateAxis = $axis; 
	dynamicaUI_activateRigidBodies();
}

global proc dynamicaUI_activateRigidBodies() 
{
	global float $dynamicaUI_activeStartFrame;
	global float $dynamicaUI_activeEndFrame;
	global int $dynamicaUI_activateAxis; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain
	global int $dynamicaUI_createActivateSet;

	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	string $sorted[];
	float $attrs[];
	string $axis;
	int $reverseAxis = 0;
	int $selChunks;
	string $refr[];
	int $incr = 0;
	int $i;

	//filter selection
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) select -add $s; //if dRigidBody
	$sel = `ls -sl`;
	for ($s in $sel) if (mbIsKeyed($s)) select -d $s; //if keyed
	$sel = `ls -sl`;
	$selChunks = (int)size($sel)/10;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		dynamicaUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	//we are go!
	dynamicaUI_print("Activating " + size($sel) + " rigid bodies...", 0);
	refresh;
	if ($dynamicaUI_createActivateSet) sets -n "ActivatedRigidBodies";

	switch ($dynamicaUI_activateAxis) 
	{
		case 0: $axis = "tx"; break;
		case 1: $axis = "tx"; $reverseAxis = 1; break;
		case 2: $axis = "ty"; break;
		case 3: $axis = "ty"; $reverseAxis = 1; break;
		case 4: $axis = "tz"; break;
		case 5: $axis = "tz"; $reverseAxis = 1; break;
		case 7: $reverseAxis = 1; break;
		case 8: break;
	}
	
	if ($dynamicaUI_activateAxis < 6) //linear axis
	{
		$sorted = mbSortObjectsByAttr($sel, $axis, 0);
		for ($o in $sorted) $attrs[size($attrs)] = `getAttr ($o + "." + $axis)`;
	}
	else if ($dynamicaUI_activateAxis == 6 || $dynamicaUI_activateAxis == 7)//radial axis
	{
		$sorted = mbProximitySort($sel);
		for ($o in $sorted) $attrs[size($attrs)] = mbDistanceBetweenNodes($sorted[0], $o);
	}
	else if ($dynamicaUI_activateAxis == 8) //daisy chain
	{
		dynamicaUI_print("Computing chain sequence...", 0);
		int $last = size($sel) - 1;
		$sorted = mbDaisyChainObjects($sel, $sel[$last], 0);
		for ($i=0;$i<size($sorted);$i++) $attrs[size($attrs)] = $i; //mbDistanceBetweenNodes($sorted[$i], $sorted[$i+1]);
	}

	if ($reverseAxis) $sorted = mbReverseStringArray($sorted);
	$attrs = mbScaleArray($attrs, $dynamicaUI_activeStartFrame, $dynamicaUI_activeEndFrame, 1);

	
	for ($i=0;$i<size($sorted);$i++) 
	{
		float $mass = `getAttr (mbGetShape($sorted[$i]) + ".mass")`;
		if ($mass == 0) $mass = 1;
		cutKey -at "mass" -cl $sorted[$i];
		setKeyframe -at "mass" -t 1 -v 1 $sorted[$i];
		setKeyframe -at "mass" -t 2 -v 0 $sorted[$i];
		setKeyframe -at "mass" -t $attrs[$i] -v $mass $sorted[$i];
		keyTangent -itt "flat" -ott "step" $sorted[$i];
		
		//visual feedback in viewport
		$refr[size($refr)] = $sorted[$i];
		$incr++;
		if ($incr == $selChunks)
		{
			select -r $refr; 
			refresh;
			$incr = 0;
			clear($refr);
			select -cl;
			refresh;
		}
	}

	dynamicaUI_print(size($sel) + " rigid bodies activated. Frame range: "
		+ $dynamicaUI_activeStartFrame + " - " + $dynamicaUI_activeEndFrame, 0);
}

global proc dynamicaUI_deactivateRigidBodies(int $toPassive)
{
	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) select -add $s; //if dRigidBody
	$sel = `ls -sl`;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		dynamicaUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	dynamicaUI_print("Removing activation from " + size($sel) + " rigid bodies...", 0);
	refresh;
	
	for ($s in $sel)
	{
		cutKey -at "mass" -cl $s;
		setAttr ($s + ".mass") 1;
		if ($toPassive) setAttr ($s + ".mass") 0;
	}
	
	if ($toPassive)
	{
		dynamicaUI_print(size($sel) + " rigid bodies made passive (mass = 0).", 0);
	}
	else
	{
		dynamicaUI_print(size($sel) + " rigid bodies made active (mass > 0).", 0);
	}
}

global proc dynamicaUI_setInitialState(int $reset)
{	
	global float $dynamicaUI_startFrame;
	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	string $constraints[];
	
	//filter selection
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) select -add $s; //if dRigidBody
	$sel = `ls -sl`;
	for ($s in $sel) if (mbIsKeyed($s)) select -d $s; //if keyed
	$sel = `ls -sl`;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		dynamicaUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	//we are go!
	dynamicaUI_print("Setting initial state for " + size($sel) + " rigid bodies...", 0);
	refresh;

	for ($s in $sel)
	{
		if ($reset)
		{
			$posX = `getAttr ($s + ".originalPositionX")`;
			$posY = `getAttr ($s + ".originalPositionY")`;
			$posZ = `getAttr ($s + ".originalPositionZ")`;
			$rotX = `getAttr ($s + ".originalRotationX")`;
			$rotY = `getAttr ($s + ".originalRotationY")`;
			$rotZ = `getAttr ($s + ".originalRotationZ")`;
			setAttr ($s + ".initialPosition") -typ double3 $posX $posY $posZ;
			setAttr ($s + ".initialRotation") -typ double3 $rotX $rotY $rotZ;
		}
		else
		{
			float $pos[] = `xform -q -ws -t $s`;
			float $rot[] = `xform -q -ws -ro $s`;
			setAttr ($s + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
			setAttr ($s + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
		}
		
		//collect connected constraints
		string $conn[];
		$rels = `listRelatives $s`;
		if (size($rels)) $conn = `listConnections $rels`;
		for($c in $conn)
		{
			$shape = mbGetShape($c);
			if (size($shape))
			{					
				if (`nodeType $shape` == "dNailConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dHingeConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dSliderConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dSixdofConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
			}
		}
	}

	currentTime $dynamicaUI_startFrame;
	dynamicaUI_updateConstraints($constraints);
}

global proc dynamicaUI_updateConstraints(string $constraints[])
{
	global float $dynamicaUI_startFrame;
	string $sel[];
	
	for ($c in $constraints)
	{
		string $type = mbGetType(mbGetShape($c));
		if ($type == "dNailConstraint") $sel[size($sel)] = $c;
		if ($type == "dHingeConstraint") $sel[size($sel)] = $c;
		if ($type == "dSliderConstraint") $sel[size($sel)] = $c;
		if ($type == "dSixdofConstraint") $sel[size($sel)] = $c;
	}
	
	for ($s in $sel)
	{
		$shape = mbGetShape($s);
		$selection = `listConnections $shape`;
		
		if (size($selection) == 1)
		{
			float $posA[] = `xform -q -ws -t $selection[0]`;
			setAttr ($s + ".translate") -typ float3 $posA[0] $posA[1] $posA[2];
		}
		if (size($selection) == 2)
		{
			float $posA[] = `xform -q -ws -t $selection[0]`;
			float $posB[] = `xform -q -ws -t $selection[1]`;
			float $pivW[3];
			$pivW[0] = mbLerpScalar($posA[0], $posB[0], 0.5);
			$pivW[1] = mbLerpScalar($posA[1], $posB[1], 0.5);
			$pivW[2] = mbLerpScalar($posA[2], $posB[2], 0.5);
			setAttr ($s + ".translate") -typ float3 $pivW[0] $pivW[1] $pivW[2];
		}
	}
}

global proc dynamicaUI_bakeRigidBodies()
{
	global int $dynamicaUI_deleteEmptyNodes;
	global int $dynamicaUI_deleteBakeHistory;
	global int $dynamicaUI_optimizeChannels;
	global int $dynamicaUI_bakeAll;
	global float $dynamicaUI_bakeStartFrame;
	global float $dynamicaUI_bakeEndFrame;
	
	string $dBakeLayer = "DynamicaBaked";
	string $bakeGroup;
	string $sel[] = `ls -sl`;
	string $toBake[];
	string $preKeyed[];
	string $baked[];
	float $progress;
	int $go = 0;
	
	select -cl;
	
	//select all rigid bodies
	if ($dynamicaUI_bakeAll) $sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) mbAddToSelection($s);
	$sel = `ls -sl`;
	
	//remove prekeyed objects from selection
	for ($s in $sel)
	{
		if (mbIsKeyed($s))
		{
			$preKeyed[size($preKeyed)] = $s;
			select -d $s;
		}
		if (!mbIsType($s, "dRigidBody"))
		{
			select -d $s;
		}
	}
	
	$sel = `ls -sl`;
	if (!size($sel)) 
	{
		select -r $sel;
		dynamicaUI_print("No rigid bodies to bake.", 2);
		return;
	}
	
	//confirm
	$confirm = `confirmDialog -t "Dynamica: Bake Rigid Bodies" -m "Bake Dynamica Simulation?\nThis action is not undoable." 
		-b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;
	if ($confirm == "No") 
	{
		select -r $sel;
		dynamicaUI_print("Bake cancelled by user.", 1);
		return;
	}
	
	//we are go
	dynamicaUI_print("Baking " + size($sel) + "rigid bodies...", 0);
	mbCreateLayer($dBakeLayer, 0);
	if ($dynamicaUI_deleteBakeHistory) delete -ch;
	undoInfo -state off;
	select -cl;
	
	//find connected transforms, modify selection
	for ($s in $sel)
	{
		$connectedTransforms = mbGetConnectedTransforms($s);
		if (size($connectedTransforms))
		{
			if (mbIsMesh($connectedTransforms[0])) 
			{
				$toBake[size($toBake)] = $connectedTransforms[0];
				mbAddToLayer($connectedTransforms[0], $dBakeLayer);
			}
		}
		else 
		{
			$toBake[size($toBake)] = $s;
			mbAddToLayer($s, $dBakeLayer);
		}
	}
	
	select -r $toBake;
	
	//bake!
	dynamicaUI_print("Dynamica: Baking simulation...", 0);
	$baked = `ls -sl`;
	cycleCheck -e off;
	bakeResults 
		-simulation 1 
		-t ((string)$dynamicaUI_bakeStartFrame + ":" + (string)$dynamicaUI_bakeEndFrame) 
		-sampleBy 1 
		-disableImplicitControl 1 
		-preserveOutsideKeys 1 
		-sparseAnimCurveBake 0
		-controlPoints 0
		-shape 0
		-at "tx" 
		-at "ty" 
		-at "tz" 
		-at "rx" 
		-at "ry" 
		-at "rz";
	
	select -cl;
	
	//delete orphans
	dynamicaUI_print("Removing orphaned rigid bodies and constraints...", 0);
	for ($s in $sel) 
	{
		select -add $s;
		string $conn[];
		$rels = `listRelatives $s`;
		if (size($rels)) $conn = `listConnections $rels`;
		for($c in $conn)
		{
			$shape = mbGetShape($c);
			if (size($shape))
			{					
				if (`nodeType $shape` == "dNailConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dHingeConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dSliderConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dSixdofConstraint" && `objExists $c` == true) select -add $c;
			}
		}

		//filter and process primitives
		if (mbIsType($s, "dRigidBody"))
		{
			$connectedTransforms = mbGetConnectedTransforms($s);
			string $connectedCollisionShape = mbGetConnectedByType(mbGetShape($s), "dCollisionShape");
			if (!size($connectedTransforms))
			{
				select -d $s;
				setAttr ($s + ".mass") 0;
			}
		}
		
		dgeval `mbGetShape($s)`;
	}

	$sel = `ls -sl`;
	if (size($sel))
	{
		dynamicaUI_print(size($sel) + " orphans found, deleting...", 0);
		delete;
	}
	
	if ($dynamicaUI_optimizeChannels) 
	{
		dynamicaUI_print("Optimizing channels...", 0);
		//delete -staticChannels -uac 0 -hi none -cp 0 -s 0; //brute force - kills all static channels in scene
		for ($b in $baked)
		{
			if (size($preKeyed)) 
			{
				for ($p in $preKeyed)
				{
					if ($b != $p)
					{
						delete -staticChannels -uac 0 -hi none -cp 0 -s 0 $b;
						break;
					}
					else
					{
						break;
					}
				}
			} 
			else 
			{
				delete -staticChannels -uac 0 -hi none -cp 0 -s 0 $b;
			}
			
			filterCurve -f simplify -timeTolerance 0 -tol 0.0001 {$b + ".rotateY", $b+ ".rotateX", $b + ".translateZ", $b + ".translateY", $b + ".translateX", $b + ".rotateZ"};
		}
	}

	if ($dynamicaUI_deleteEmptyNodes)
	{
		dynamicaUI_print("Removing empty nodes...", 0);
		mbDeleteEmptyNodes();
	}

	if ($dynamicaUI_deleteBakeHistory)
	{
		dynamicaUI_print("Removing history...", 0);
		delete -all -ch;
		
		for ($b in $baked) mbDeleteShapeHistory($b); //clean shape history
	}
	
	undoInfo -state on;
	select -r $baked;
	$bakeGroup = `group -em -n dBaked`;
	for ($b in $baked) parent $b $bakeGroup; //move to baked group
	dynamicaUI_print("Baked " + size($baked) + " rigid bodies on frames " + $dynamicaUI_bakeStartFrame + " - " + $dynamicaUI_bakeEndFrame, 0);
}

//callbacks
global proc int bulletExportOptions( string $parent, string $action, string $settings, string $callback ) 
{
	return 1;
}

//script jobs
global proc dynamicaUI_syncSolver()
{
	if (`objExists dSolver1`)
	{
		global float $dynamicaUI_startFrame;
		float $startFrame = `playbackOptions -q -min`;
		setAttr "dSolver1.startTime" $startFrame;
		$dynamicaUI_startFrame = $startFrame;
		dynamicaUI_print("Updated solver Start Time to: " + (string)$dynamicaUI_startFrame, 0);
	}
}

global proc dynamicaUI_onSceneOpen()
{
	global int $dynamicaUI_syncSolverJob = -1;
	if (!`scriptJob -ex $dynamicaUI_syncSolverJob`)
	{
		$dynamicaUI_syncSolverJob = `scriptJob -kws -e "playbackRangeChanged" dynamicaUI_syncSolver`;
	}
}

global proc dynamicaUI_onPluginLoad()
{
	global int $dynamicaUI_sceneOpenJob = -1;
	if (!`scriptJob -ex $dynamicaUI_sceneOpenJob`)
	{
		$dynamicaUI_sceneOpenJob = `scriptJob -e "SceneOpened" dynamicaUI_onSceneOpen`;
	}
	
	dynamicaUI_onSceneOpen();
}

